{
  "meta": {},
  "items": [
    {
      "itemID": "000",
      "menu_item": "How to Build a No-Code RAG System (Pinecone - Make)\nWEB ORIGINAL:",
      "contenido": "How to Build a No-Code RAG System (Pinecone - Make):\nWeb Original:\n\nHow to Build a No-Code RAG System (Pinecone - Make)\n https://youtu.be/DNDI4c3z-6A?si=YHle_tasVuzr6tmB"
    },
    {
      "itemID": "001",
      "menu_item": "Introducción a los Sistemas RAG y sus Beneficios",
      "contenido": "Introducción a los Sistemas RAG y sus Beneficios:\n\nEste tutorial le guiará a través de la creación de un sistema de Generación Aumentada por Recuperación (RAG) sin código, utilizando Pinecone para el almacenamiento vectorial y Make.com para la automatización. El objetivo principal es cargar una base de conocimiento de documentos y utilizar modelos de lenguaje grandes (LLMs) como Claude o ChatGPT para generar artículos precisos y personalizados, basándose únicamente en la información que usted proporciona. Esta técnica es fundamental para construir soluciones de IA robustas y fiables.\n\nLa técnica RAG aborda una limitación clave de los LLMs: su tendencia a \"alucinar\" o inventar información cuando no tienen el contexto específico que usted necesita. Al augmentar (añadir) los prompts de los LLMs con información altamente relevante recuperada de una base de conocimiento externa, se mejora drásticamente la precisión y la relevancia del contenido generado. Imagínese poder generar un artículo detallado para una tienda en línea, incluyendo imágenes, descripciones de productos, especificaciones, tiempos de envío y políticas de devolución, todo ello fundamentado en sus propios datos.\n\nLos sistemas RAG se dividen en dos fases principales:\n1.  **Fase de Carga (Upsert)**: Aquí, su base de conocimiento (documentos, PDFs, datos web, etc.) se transforma en representaciones numéricas llamadas \"vectores\" mediante modelos de *embeddings* (como los de OpenAI) y se almacena en una base de datos vectorial (como Pinecone).\n2.  **Fase de Generación/Consulta**: Cuando un usuario realiza una consulta, esta también se convierte en un vector. Este vector se utiliza para buscar el conocimiento más relevante en la base de datos vectorial. La información recuperada se añade al prompt del LLM, permitiéndole generar una respuesta precisa y contextual.\n\nFrente a la creación manual de prompts contextuales, que es costosa y propensa a errores (demasiado \"ruido\" puede reducir la precisión), RAG ofrece un \"prompting contextual dinámico\". Esto significa que el sistema recupera automáticamente la información más pertinente, asegurando que el LLM siempre trabaje con los datos más relevantes."
    },
    {
      "itemID": "002",
      "menu_item": "Elección de Herramientas: Pinecone y Make.com",
      "contenido": "Elección de Herramientas: Pinecone y Make.com:\n\nAunque existen soluciones más sencillas, como los OpenAI Assistants con RAG integrado, la combinación de Pinecone y Make.com ofrece una flexibilidad superior. Esta configuración le permite:\n\n1.  **Utilizar cualquier modelo de *embedding***: No está limitado a los modelos de OpenAI, pudiendo elegir el que mejor se adapte a sus necesidades o presupuesto.\n2.  **Emplear cualquier LLM**: Puede integrar LLMs de diferentes proveedores o modelos *open-source* como Llama 3 o Mistral, en lugar de estar atado a la oferta de OpenAI.\n\nEsta mayor complejidad inicial se traduce en un control más granular y una capacidad de adaptación futura para sus soluciones de IA."
    },
    {
      "itemID": "003",
      "menu_item": "Fase 1: Preparación de Datos y Configuración de Pinecone",
      "contenido": "Fase 1: Preparación de Datos y Configuración de Pinecone:\n\nAntes de construir nuestro sistema RAG, necesitamos preparar los datos que formarán nuestra base de conocimiento y configurar nuestra base de datos vectorial.\n\n1.  **Fuente de Datos**: Utilizaremos una hoja de Google Sheets. Esta hoja debe contener información estructurada, como páginas estáticas y productos de una tienda de comercio electrónico ficticia. Asegúrese de que sus datos estén en un formato digerible (CSV, Excel, JSON). Para este tutorial, cada fila de la hoja de Google representa un \"registro\" o \"documento\" de nuestra base de conocimiento.\n2.  **Configuración de Pinecone**:\n    *   Cree una cuenta en Pinecone. La plataforma ofrece un plan gratuito que es suficiente para empezar.\n    *   Una vez dentro, cree un nuevo índice. Este índice será donde se almacenen sus vectores.\n    *   **Nombre del índice**: Asigne un nombre descriptivo, como \"make-automation\".\n    *   **Dimensiones del vector**: Configure las dimensiones en 1536. Este número es crucial porque coincide con las dimensiones de salida del modelo de *embeddings* `text-embeddings-3-small` de OpenAI, que utilizaremos. Si usara otro modelo de *embeddings*, este valor cambiaría.\n3.  **Conexión de Make.com con Pinecone**:\n    *   En Make.com, necesitará establecer una conexión con Pinecone.\n    *   Localice la URL de su índice de Pinecone (la encontrará en la configuración de su índice).\n    *   Utilice esta URL y su clave API de Pinecone para configurar la conexión en Make.com. Asegúrese de eliminar `https://` y `.pinecone.io` de la URL del índice para la configuración."
    },
    {
      "itemID": "004",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 1: Google Sheets",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 1: Google Sheets:\n\nAhora construiremos el primer escenario en Make.com, que se encargará de cargar los datos de nuestra base de conocimiento a Pinecone. Este escenario se conoce como \"Upserting Vectors\" (Insertar o Actualizar Vectores).\n\nEl primer módulo de nuestro escenario será para obtener los datos de la hoja de Google Sheets:\n\n1.  **Añada el módulo \"Google Sheets - Get Range Values\"**: Este módulo conectará con su hoja de cálculo.\n2.  **Seleccione la hoja**: Elija la pestaña específica donde se encuentran sus datos, por ejemplo, \"knowledge base\".\n3.  **Defina el rango**: Especifique el rango de celdas que contienen sus datos. Por ejemplo, `A2` a `M51` para incluir todas las filas y columnas relevantes (excluyendo la cabecera si está en la fila 1).\n4.  Este módulo leerá sus datos fila por fila, enviando cada fila como un \"bundle\" o paquete individual para su procesamiento posterior."
    },
    {
      "itemID": "005",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 2: Set Multiple Variables",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 2: Set Multiple Variables:\n\nEste módulo es crucial para preprocesar los datos antes de enviarlos a OpenAI y Pinecone.\n\n1.  **Añada el módulo \"Set Multiple Variables\"**:\n2.  **Problema con caracteres inseguros**: El texto dinámico que proviene de Google Sheets puede contener caracteres que no son seguros para un formato JSON (como comillas dobles sin escapar, saltos de línea, etc.). Dado que Make.com no tiene una función nativa de escape de JSON, necesitamos una solución alternativa.\n3.  **Variable 'Json safe string'**: Cree una nueva variable con este nombre. Su valor será una fórmula que reemplace o escape los caracteres no seguros. Puede encontrar ejemplos de estas fórmulas en la descripción del video original o buscar una función de escape de JSON adaptada a Make.com. El objetivo es que el texto sea seguro para ser interpretado como parte de una estructura JSON.\n4.  **Variable 'Full Record'**: Cree una segunda variable llamada 'Full Record'. Esta variable contendrá toda la información de la fila actual (el registro completo) en un formato JSON seguro. Esto es importante porque queremos que el LLM tenga acceso a todos los detalles de la página o producto cuando genere contenido. Asegúrese de que esta variable también utilice la lógica de escape de JSON si es necesario."
    },
    {
      "itemID": "006",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 3: OpenAI Embeddings",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 3: OpenAI Embeddings:\n\nEste módulo es el encargado de transformar el texto de su base de conocimiento en representaciones numéricas, o vectores, que Pinecone puede almacenar y buscar.\n\n1.  **Añada el módulo \"OpenAI - Make an API Call\"**:\n2.  **Endpoint**: Configure el endpoint como `/v1/embeddings`. Este es el punto de acceso para los servicios de *embeddings* de OpenAI.\n3.  **Modelo**: Seleccione el modelo `text-embeddings-3-small`. Este modelo es eficiente y compatible con las 1536 dimensiones que configuramos en Pinecone.\n4.  **Input**: Mapee aquí el valor de su variable `'Json safe string'` o `'Full Record'` (dependiendo de si desea incrustar solo un resumen o el registro completo). Este texto es lo que OpenAI convertirá en un vector.\n5.  El resultado de este módulo será un array de números que representan semánticamente el texto de entrada. Estos números son los que se almacenarán en Pinecone."
    },
    {
      "itemID": "007",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 4: Pinecone Get a Vector",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 4: Pinecone Get a Vector:\n\nEste módulo nos permite verificar si un registro específico (identificado por su Vector ID) ya existe en nuestro índice de Pinecone. Esto es vital para evitar duplicados y optimizar las actualizaciones.\n\n1.  **Añada el módulo \"Pinecone - Get a Vector\"**:\n2.  **Vector ID**: Utilice un identificador único para cada registro. En este caso, el `'Page Link'` (URL) de la hoja de Google Sheets es una excelente opción, ya que cada página/producto tendrá una URL única. Mapee el campo `Page Link` de su módulo de Google Sheets aquí.\n3.  Pinecone intentará recuperar el vector asociado a ese `Vector ID`. Si el vector existe, devolverá sus valores y metadatos. Si no existe, el módulo no devolverá nada, lo que indicará que es un nuevo registro."
    },
    {
      "itemID": "008",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 5: Filtro de Actualización",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 5: Filtro de Actualización:\n\nEntre el módulo \"Pinecone - Get a Vector\" y el siguiente módulo \"Pinecone - Upsert a Vector\", inserte un filtro. Este filtro es crucial para optimizar el proceso, ya que evita realizar operaciones de `upsert` (inserción/actualización) innecesarias si el contenido del registro no ha cambiado.\n\n1.  **Añada un filtro**: Conecte el módulo \"Pinecone - Get a Vector\" con el siguiente módulo de Pinecone a través de un filtro.\n2.  **Condiciones del filtro (lógica OR)**: El módulo de `upsert` solo debe ejecutarse si se cumple al menos una de las siguientes condiciones:\n    *   **Condición A: El Vector ID NO EXISTE**. Esto significa que el módulo \"Pinecone - Get a Vector\" no encontró ningún resultado para el `Vector ID` dado. Esto indica un nuevo registro que debe ser insertado.\n    *   **Condición B: El 'Unique Hash' NO ES IGUAL**. Para esto, primero necesita generar un hash único (por ejemplo, usando el algoritmo SHA-256) del contenido de su `'Full Record'` (la variable que creamos en el Módulo 2). Almacene este hash en los metadatos de Pinecone cuando inserte o actualice un vector (ver Módulo 6). Si el hash actual del `'Full Record'` (generado en el momento de la ejecución) NO ES IGUAL al `'Unique Hash'` almacenado en los metadatos de Pinecone para ese `Vector ID`, significa que el contenido ha cambiado y el vector necesita ser actualizado.\n3.  Este filtro asegura que solo los registros nuevos o modificados se envíen a Pinecone, ahorrando costos y tiempo de procesamiento."
    },
    {
      "itemID": "009",
      "menu_item": "Fase 1: Escenario de Make.com (Carga) - Módulo 6: Pinecone Upsert a Vector",
      "contenido": "Fase 1: Escenario de Make.com (Carga) - Módulo 6: Pinecone Upsert a Vector:\n\nEste es el módulo final de la fase de carga. Es el encargado de insertar nuevos vectores o actualizar los existentes en Pinecone.\n\n1.  **Añada el módulo \"Pinecone - Upsert a Vector\"**: Asegúrese de que esté conectado después del filtro del módulo anterior.\n2.  **Vector ID**: Mapee nuevamente el `'Page Link'` (URL) de su hoja de Google Sheets. Este es el identificador único de cada vector.\n3.  **Values**: Aquí debe mapear el array completo de *embeddings* que fue generado por el módulo \"OpenAI - Make an API Call\" (Módulo 3). Estos son los números que representan semánticamente su contenido.\n4.  **Metadata**: Esta es una característica esencial de Pinecone que OpenAI no ofrece en su propio *vector store* integrado. La metadata le permite almacenar información legible y estructurada junto con su vector, sin que esta información sea parte directa del *embedding*. Es crucial para la recuperación contextual. Incluya los siguientes campos:\n    *   **Content**: Mapee su variable `'Full Record'` aquí. Make.com se asegurará de que sea JSON-safe. Esta será la información textual que el LLM usará directamente.\n    *   **Title**: Mapee el título de la página/producto de su hoja de Google Sheets.\n    *   **Unique Hash**: Mapee el hash único (SHA-256) de su `'Full Record'` que calculó previamente. Esto es vital para las futuras comprobaciones del filtro y determinar si un registro ha cambiado.\n5.  Una vez configurado, este módulo se encargará de mantener su índice de Pinecone actualizado con la información de su base de conocimiento."
    },
    {
      "itemID": "010",
      "menu_item": "Fase 1: Ejecución del Escenario de Carga",
      "contenido": "Fase 1: Ejecución del Escenario de Carga:\n\nCon todos los módulos configurados, es momento de ejecutar el escenario de Make.com para cargar su base de conocimiento en Pinecone.\n\n1.  **Guarde su escenario**: Asegúrese de que todos los cambios estén guardados en Make.com.\n2.  **Ejecute el escenario**: Active el escenario de forma manual o programada.\n3.  **Verificación**: Observe cómo los \"bundles\" de datos fluyen a través de los módulos. Debería ver cómo cada fila de su hoja de Google Sheets es procesada, convertida en un *embedding* por OpenAI y luego insertada o actualizada en su índice de Pinecone.\n4.  **Comprobación en Pinecone**: Puede ir a la interfaz de Pinecone y verificar que los vectores y sus metadatos se hayan cargado correctamente en el índice \"make-automation\". Debería ver el número de vectores aumentar hasta igualar el número de registros en su hoja de Google Sheets."
    },
    {
      "itemID": "011",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 1: Google Sheets (Consulta)",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 1: Google Sheets (Consulta):\n\nAhora construiremos el segundo escenario en Make.com, que se encargará de la recuperación de información y la generación de artículos con RAG.\n\nEl primer módulo de este escenario servirá para obtener la consulta o la solicitud de artículo que queremos generar.\n\n1.  **Añada el módulo \"Google Sheets - Get Range Values\"**: Similar al primer escenario, pero esta vez lo usaremos para leer la consulta.\n2.  **Seleccione la hoja**: Elija la pestaña donde escribirá las descripciones de los artículos que desea generar, por ejemplo, la pestaña \"Articles\".\n3.  **Defina el rango**: Especifique la celda o el rango donde se encuentra la descripción de su artículo o su consulta. Este será el punto de partida para la generación del contenido."
    },
    {
      "itemID": "012",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 2: OpenAI para Extracción del Término de Búsqueda",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 2: OpenAI para Extracción del Término de Búsqueda:\n\nSi la descripción del artículo es muy larga, puede que no sea el mejor \"término de búsqueda\" directo para Pinecone. Es más eficiente extraer los conceptos clave.\n\n1.  **Añada el módulo \"OpenAI - Create a Completion\"**: Este módulo se usará para pedirle a un LLM que nos ayude a digerir la consulta.\n2.  **Modelo**: Elija un modelo de OpenAI (por ejemplo, GPT-3.5 Turbo o GPT-4o si desea más precisión).\n3.  **System Message**: Instruya al LLM con un mensaje claro: \"Eres un asistente diseñado para extraer términos de búsqueda concisos. Basándote en la siguiente descripción de artículo, propón los términos de búsqueda más relevantes para una base de conocimiento.\"\n4.  **User Message**: Proporcione al LLM la descripción del artículo obtenida del Módulo 1 de Google Sheets.\n5.  **Formato**: Es crucial pedir al LLM que la respuesta sea en formato JSON. Por ejemplo: `{\"search_term\": \"termino clave para buscar\"}`. Esto facilitará la extracción posterior del término de búsqueda.\n6.  El objetivo es que este módulo devuelva un término de búsqueda más corto y relevante que la descripción original, optimizando la búsqueda en Pinecone."
    },
    {
      "itemID": "013",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 3: OpenAI Embeddings de la Consulta",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 3: OpenAI Embeddings de la Consulta:\n\nUna vez que tenemos nuestro término de búsqueda conciso, necesitamos convertirlo en un vector para poder buscarlo en Pinecone.\n\n1.  **Añada el módulo \"OpenAI - Make an API Call\"**: Este módulo es idéntico al que usamos en la fase de carga.\n2.  **Endpoint**: Configure el endpoint como `/v1/embeddings`.\n3.  **Modelo**: Vuelva a seleccionar `text-embeddings-3-small` para asegurar la coherencia con los vectores almacenados en Pinecone.\n4.  **Input**: Mapee el término de búsqueda conciso que fue extraído del JSON generado por el Módulo 2. Si el Módulo 2 no está presente (por ejemplo, si usa directamente la descripción del artículo como término de búsqueda), mapee la descripción original.\n5.  El output de este módulo será el array de vectores que representa semánticamente nuestra consulta."
    },
    {
      "itemID": "014",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 4: Pinecone Query Vectors",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 4: Pinecone Query Vectors:\n\nEste es el corazón de la fase de recuperación. Aquí le decimos a Pinecone que encuentre los vectores más similares a nuestra consulta.\n\n1.  **Añada el módulo \"Pinecone - Query Vectors\"**:\n2.  **Input**: Mapee el array de vectores generado en el Módulo 3 (los *embeddings* de su consulta).\n3.  **Incluir Metadata**: Seleccione \"Sí\". Esto es vital, ya que queremos recuperar no solo los vectores, sino también el texto real (el \"Content\" que almacenamos en la metadata) asociado a esos vectores, que es lo que usaremos para aumentar nuestro prompt.\n4.  **Limit**: Establezca el número máximo de resultados que desea recuperar. Por ejemplo, `4` o `10`. Un número mayor puede introducir \"ruido\" si los resultados son menos relevantes, mientras que un número menor puede omitir información importante. Experimente para encontrar el valor óptimo.\n5.  **Nota sobre *Re-ranking***: Aunque se menciona, para simplificar este tutorial, omitiremos una fase de *re-ranking*. En sistemas RAG más avanzados, se puede añadir un paso adicional para reordenar los resultados recuperados y asegurar que los más relevantes estén en la parte superior, utilizando un modelo de lenguaje para una evaluación más profunda."
    },
    {
      "itemID": "015",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 5: Array Aggregator",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 5: Array Aggregator:\n\nEl módulo \"Pinecone - Query Vectors\" puede devolver múltiples \"bundles\" de resultados, uno por cada vector relevante encontrado. Para poder pasar toda esta información como un único bloque al LLM, necesitamos consolidarla.\n\n1.  **Añada el módulo \"Array Aggregator\"**: Conéctelo al módulo \"Pinecone - Query Vectors\".\n2.  **Elementos a agregar**: Indique qué campos desea consolidar de cada resultado. Los más importantes serán:\n    *   `Vector ID` (la URL de la página, para referencia).\n    *   `Metadata.Content` (el texto completo del registro que habíamos almacenado).\n    *   `Metadata.Title` (el título de la página).\n3.  Este módulo tomará todos los \"bundles\" de resultados individuales y los combinará en un único array estructurado."
    },
    {
      "itemID": "016",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 6: Transform to JSON",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 6: Transform to JSON:\n\nAhora que tenemos todos los resultados relevantes agregados en un array, el siguiente paso es convertirlos en una única cadena JSON. Esta cadena será nuestro \"conocimiento relevante\" que inyectaremos en el prompt del LLM.\n\n1.  **Añada el módulo \"Transform to Json\"**: Conéctelo al módulo \"Array Aggregator\".\n2.  **Input**: Mapee el array de resultados que generó el módulo \"Array Aggregator\".\n3.  Este módulo generará una cadena de texto en formato JSON que contendrá toda la información recuperada de Pinecone. Por ejemplo, `[{\"Vector ID\": \"...\", \"Content\": \"...\", \"Title\": \"...\"}, {\"Vector ID\": \"...\", \"Content\": \"...\", \"Title\": \"...\"}]`. Esta cadena es el \"contexto\" o la \"fundamentación\" que se le dará al LLM."
    },
    {
      "itemID": "017",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 7: OpenAI para Generación Final",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 7: OpenAI para Generación Final:\n\nEste es el módulo final y el más importante para la generación del contenido. Aquí, el LLM utilizará tanto su consulta original como el conocimiento relevante recuperado para escribir el artículo.\n\n1.  **Añada el módulo \"OpenAI - Create a Completion\"**:\n2.  **Modelo**: Utilice un modelo potente como `GPT-4o` para obtener los mejores resultados en la generación de texto.\n3.  **System Message (Prompt Aumentado)**: Aquí es donde inyectamos la magia del RAG. El mensaje del sistema le dirá al LLM cómo comportarse y cómo usar la información que le proporcionamos. Un ejemplo sería:\n    \"Eres un escritor de artículos experto y preciso para una tienda en línea. Tu tarea es redactar un artículo basado en la descripción proporcionada por el usuario. Es CRÍTICO que fundamentes cada afirmación y detalle del artículo en los hechos proporcionados en la 'INFORMACIÓN DE CONTEXTO' que te daré. No inventes información. Si algo no está en la 'INFORMACIÓN DE CONTEXTO', indícalo o omítelo.\"\n4.  **User Message**: Combine la descripción original del artículo (del Módulo 1 de Google Sheets) con la cadena JSON de \"conocimiento relevante\" generada por el Módulo 6. Un ejemplo de cómo estructurarlo sería:\n    \"Descripción del Artículo: [Descripción del artículo del Módulo 1]\n\n    INFORMACIÓN DE CONTEXTO:\n    [Cadena JSON del Módulo 6]\"\n5.  El LLM procesará esta entrada y generará un artículo que será preciso y estará directamente basado en los datos de su base de conocimiento."
    },
    {
      "itemID": "018",
      "menu_item": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 8: Google Sheets para Guardar el Artículo",
      "contenido": "Fase 2: Escenario de Make.com (Generación RAG) - Módulo 8: Google Sheets para Guardar el Artículo:\n\nEl último paso en este escenario es guardar el artículo generado por el LLM en su hoja de Google Sheets.\n\n1.  **Añada el módulo \"Google Sheets - Update a Cell\"**:\n2.  **Ubicación**: Especifique la pestaña y la columna donde desea guardar el artículo. Por ejemplo, en la pestaña \"Articles\", columna `B`. Asegúrese de mapear el número de fila que obtuvo del Módulo 1 para que el artículo se guarde junto a su descripción original.\n3.  **Valor**: Mapee la salida del módulo \"OpenAI - Create a Completion\" (Módulo 7), que es el artículo final generado.\n4.  Una vez ejecutado, el artículo completo aparecerá en su hoja de Google Sheets, listo para ser revisado o utilizado."
    },
    {
      "itemID": "019",
      "menu_item": "Verificación del Resultado Final",
      "contenido": "Verificación del Resultado Final:\n\nDespués de ejecutar la Fase 2 (Generación de Artículos RAG) en Make.com, es crucial verificar la calidad y precisión del artículo generado.\n\n1.  **Revise el artículo en Google Sheets**: Abra la hoja de Google Sheets donde el artículo fue guardado (Módulo 8).\n2.  **Compare con la base de conocimiento**: Examine el contenido del artículo. Debería observar que el artículo incluye detalles específicos y \"fact-checked\" (verificados con hechos) que provienen directamente de su base de conocimiento cargada en Pinecone. Esto podría incluir:\n    *   Precios exactos de productos.\n    *   Dimensiones o especificaciones técnicas.\n    *   Información sobre el envío (por ejemplo, \"5-7 días hábiles\", \"costo de envío de $16\").\n    *   Políticas de devolución o información sobre tarjetas de regalo.\n3.  La presencia de estos detalles, que usted no escribió manualmente en el prompt, es la prueba de que su sistema RAG está funcionando correctamente, recuperando información relevante y usándola para fundamentar las respuestas del LLM. Esto demuestra la capacidad del sistema para generar contenido altamente preciso y personalizado."
    },
    {
      "itemID": "020",
      "menu_item": "VALIDACIÓN CON FUENTES TÉCNICAS OFICIALES",
      "contenido": "VALIDACIÓN CON FUENTES TÉCNICAS OFICIALES:\n\nEste tutorial ha demostrado cómo construir un sistema RAG sin código utilizando Pinecone y Make.com. Los puntos clave cubiertos incluyen la fase de carga (upsert) de datos en Pinecone mediante la generación de embeddings con OpenAI y la gestión de metadatos, así como la fase de generación que involucra la consulta a Pinecone, la agregación de resultados y el aumento del prompt de un LLM para la creación de contenido preciso y contextual. La flexibilidad de esta arquitectura permite la integración de diversos modelos de embeddings y LLMs, superando las limitaciones de soluciones más cerradas.\n\nReferencias y Fuentes Técnicas:\n\n*   **Documentación Oficial de Pinecone**: Para detalles sobre la creación de índices, gestión de vectores, consultas y el uso de metadatos.\n    *   URL: https://www.pinecone.io/docs/\n*   **Documentación Oficial de Make.com (anteriormente Integromat)**: Para guías sobre la creación de escenarios, módulos, filtros, agregadores de arrays y funciones de transformación de datos.\n    *   URL: https://www.make.com/en/help\n*   **Documentación Oficial de OpenAI API (Embeddings y Completions)**: Para información detallada sobre los modelos de embeddings (e.g., `text-embeddings-3-small`), sus dimensiones, el uso del endpoint `/v1/embeddings`, y la creación de completions con mensajes de sistema y usuario para LLMs (e.g., GPT-4o).\n    *   URL: https://platform.openai.com/docs/\n*   **Google Sheets API/Documentación**: Para la integración con hojas de cálculo, lectura de rangos y actualización de celdas.\n    *   URL: https://developers.google.com/sheets/api/guides/concepts\n*   **Conceptos de Retrieval Augmented Generation (RAG)**: Para una comprensión más profunda de la teoría y beneficios de RAG en la mejora de la precisión de los LLMs.\n    *   URL: (Puede buscar artículos académicos o de blogs de empresas de IA como Hugging Face, Google AI, etc.)"
    }
  ]
}